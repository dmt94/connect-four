/*
STATE VARIABLES:
(we will have "render" functions to update game based on player choices/moves)

  turns:
    1 (player 1, main player)
    -1 (player 2, computer)

  game dimension:
  - row x column or single array
  - 2 dimensional array <<- 
      - board: 2D array
  - empty: null 
      - represent no one is playing yet

  winner:
    - null
      - represents no winner / in play
      - game is still in process
    - if winner
        - set to number 1/-1
    - "T" 
      - represents a TIE

determine which HTML is static and which can change due to 
render fn based on user interaction
  - if board change based on difficulty 
    - wise to use container to leave empty
    - board will be generated by JavaScript
  - for this game, arrow marker would change


we map state to DOM
*/


/*----- constants -----*/
const COLORS = {
  '0': {
    color: 'rgba(255, 255, 255, 0)',
    name: 'No player'
  },
  '1': {
    color: "var(--player-one)",
    name: 'Player'
  },
  '-1': {
    color: "var(--computer)",
    name: 'Computer'
  }
}

let board; //array of col arrays (7 column)
let turn = 1; // 1 or -1 (player vs computer)
let winner; //null = no winner; 1 || -1 = winner; "T" = tie
let isNightMode = false;
/*----- state variables -----*/


/*----- cached elements  -----*/
const messageEl = document.querySelector("h1");
const playAgainBtn = document.getElementById("play-again");
const toggleBtn = document.getElementById("toggle-btn")
//iterable
const markerEls = [...document.querySelectorAll("#markers > div")];

/*----- event listeners -----*/
//utilize envent delegation
document.getElementById("markers").addEventListener("click", handleDrop);
playAgainBtn.addEventListener("click", init);
toggleBtn.addEventListener("click", themeChange);

/*----- functions -----*/
function themeChange() {
  const markers = document.querySelectorAll("#markers > div");
  const dayMarkerColor = "var(--day-markers-border-c)";
  const nightMarkerColor = "var(--night-markers-border-c)";
  const bodyEl = document.querySelector("body");
  const headerEl = document.querySelector("header");
  const h1El = document.querySelector("h1");
  if (isNightMode === false) {
    isNightMode = true;
    markers.forEach((marker) => marker.style.borderColor = nightMarkerColor)
  } else {
    isNightMode = false;
    markers.forEach((marker) => marker.style.borderColor = dayMarkerColor)
  }
  bodyEl.classList.toggle("dark-mode");
  headerEl.classList.toggle("dark-mode");
  h1El.classList.toggle("dark-mode");
}

init();
//initialize all state, then call render()
//first step mirrors the visual gameboard, 
function init() {
  //to visualize the board's mapping to the DOM,
  //rotate the board array 90 degrees counter-clockwise
  //we want to start from the bottom row
  board = [
    [0, 0, 0, 0, 0, 0], // col 0
    [0, 0, 0, 0, 0, 0], // col 1
    [0, 0, 0, 0, 0, 0], // col 2
    [0, 0, 0, 0, 0, 0], // col 3
    [0, 0, 0, 0, 0, 0], // col 4
    [0, 0, 0, 0, 0, 0], // col 5
    [0, 0, 0, 0, 0, 0], // col 6
  ];
  turn;
  winner = null;
  render();
}

// In response to user interaction, update all impacted state
// then call render();
function handleDrop(evt) {
  const colIdx = markerEls.indexOf(evt.target);
  //Guards
  if (colIdx === -1) return;
  //Shortcut to column array
  const colArr = board[colIdx];
  //Find the index of the first 0 in colArr
  //0 represents empty space, we are trying to find the next available slot to fill with (1 or -1) after checking that the entire column is not filled yet
  const rowIdx = colArr.indexOf(0);
  //update board state with current player value
  colArr[rowIdx] = turn;
  //switch player turn
  //bc 1 * -1 = -1 (other players turn)
  //bc -1 * -1 = 1 (computer turn)
  turn *= -1;
  //check for winner
  winner = getWinner(colIdx, rowIdx);

  render();
}

//check winner in board state
// return null if no winner, 1/-1 if player has won, "T" if it is tie
function getWinner(colIdx, rowIdx) {
  //vertical, horizontal, diagonal (NE-SW)(NW-SE)
  return checkVerticalWin(colIdx, rowIdx) || checkHorizontalWin(colIdx, rowIdx) ||
  checkDiagonalWinNESW(colIdx, rowIdx) || checkDiagonalWinNWSE(colIdx, rowIdx);
}

//vertical win check
function checkVerticalWin(colIdx, rowIdx) {
  //reusable function to check sides of most recent turn
  //returns count of directin using offset
  return countAdjacent(colIdx, rowIdx, 0, -1) === 3 ? board[colIdx][rowIdx] : null;
}

function checkHorizontalWin(colIdx, rowIdx) {
  const adjCountLeft = countAdjacent(colIdx, rowIdx, -1, 0);
  const adjCountRight = countAdjacent(colIdx, rowIdx, 1, 0);
  return (adjCountLeft + adjCountRight >= 3 ? board[colIdx][rowIdx]: null);
}

function checkDiagonalWinNESW(colIdx, rowIdx) {
  //remember which direction we are checking --> positive or negative
  const adjCountNE = countAdjacent(colIdx, rowIdx, 1, 1);
  const adjCountSW = countAdjacent(colIdx, rowIdx, -1, -1);
  return (adjCountNE + adjCountSW) >= 3 ? board[colIdx][rowIdx] : null;
}

function checkDiagonalWinNWSE(colIdx, rowIdx) {
  const adjCountNW = countAdjacent(colIdx, rowIdx, -1, 1);
  const adjCountSE = countAdjacent(colIdx, rowIdx, 1, -1);
  return (adjCountNW + adjCountSE) >= 3 ? board[colIdx][rowIdx] : null;
}

//REUSABLE FN to use to check other orientation for WIN
//offset = count from last move
function countAdjacent(colIdx, rowIdx, colOffset, rowOffset) {
  //shortcut variable to the player value
  const player = board[colIdx][rowIdx];
  //track count of adjacent cells with the same player value;
  let count = 0;
  //initialize new coordinates
  colIdx += colOffset;
  rowIdx += rowOffset;
  //set board boudary check
  while (
    //ensure that the colIdx is within bounds of the board array
    board[colIdx] !== undefined && 
    board[colIdx][rowIdx] !== undefined &&
    board[colIdx][rowIdx] === player
  ) {
    count++;
    colIdx += colOffset;
    rowIdx += rowOffset;
  }
  return count;
} 


//visualize all state in the DOM
function render() {
  renderBoard();
  renderMessage();
  // hide / show UI elements (controls)
       // - play again and markers
  renderControls();
}

function renderBoard() {
  //need value of index for each div in board (circles)
  board.forEach((colArr, colIdx) => {
    //iterate over the cells in the current column (colArr)
    colArr.forEach((cellVal, rowIdx) => {
      const cellId = `c${colIdx}r${rowIdx}`;
      const cellEl = document.getElementById(cellId);
      cellEl.style.backgroundColor = COLORS[cellVal].color;
    })
  })
}

function renderMessage() {
  let currentPlayer = COLORS[turn];
  let winningPlayer = COLORS[winner];
  if (winner === "T") {
    messageEl.innerText = "It's a Tie!!";
  } 

  else if (winner) {
    // messageEl.innerHTML = `${COLORS[1].name} WON!`;
    messageEl.innerHTML = `<span style="color: ${winningPlayer.color}">${winningPlayer.name.toUpperCase()}</span> WINS!`;

  } else {
    //Game is in play
    messageEl.innerHTML = `<span style="color: ${currentPlayer.color}">${currentPlayer.name.toUpperCase()}</span>'s turn`;
  }
}

//IMPORTANT!!
function renderControls() {
  //ternary expression is the go to when you want 1 of 2 values returned
  // winner is truthy
  playAgainBtn.style.visibility = winner ? "visible" : "hidden";
  // iterate over the marker elements to hide/show 
  // according to the COLUMN being completely filled = no 0s
  markerEls.forEach((markerEl, colIdx) => {
    //returns column array, length is 6
    // left = false if there are 0s left, true if there are
    // right = false if there is no winner (falsey null), 
            // true if there is winner (truthy 1 or -1)  
  const hideMarker = !board[colIdx].includes(0) || winner; 
    //if hideMarker is true = visibility = hidden
    //else if hideMarker is false = visibility = visibile
  markerEl.style.visibility = hideMarker ? "hidden" : "visible";
  });
}



